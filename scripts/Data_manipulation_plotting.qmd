---
title: "Data_Manipulation"
author: "Simon Lotz"
format: html
editor: visual
---

# Data manipulation and plotting

DHP_LAI = LAI from hemispherical photos LT_LAI = LAI from the Littertraps (leafarea.py script) DHP_LAI_2BG = LAI from hemispherical photos with enhanced contrast such as suggested in the


```{r setting up R Workspace}
library(lme4)
library(MuMIn)
library(dplyr)
library(ggplot2)
library(patchwork)
library(RColorBrewer)
library(png)
library(jpeg)
library(ggforce)
library(tidyr)
library(patchwork)
library(segmented)
library(grid)
library(magick)
```


## Data manipulation
```{r define plot IDS wo conifer trees}
# Define plot IDs without conifer trees
plot_ids_wo_conifer <- c("LT11", "LT13", "LT14", "LT23", "LT24",
                         "LT33", "LT41", "LT44", "LT34",
                         "LT51", "LT52", "LT53", "LT61", "LT62", "LT63")
```

```{r loading in the data}
#loading in the data
DHP_LAI <- read.csv('results/DHP_processed.csv', header = T)

DHP_LAI_Hinge <- read.csv('results/DHP_processed_hinge.csv', header = T)

LT_LAI <- read.csv('data/LT_processed/leaf_area.csv', header = T)
```

join the Hinge data to the big LAI Dataset
```{r join Hinge}
DHP_LAI$canopy.MTA.ell <- NULL
DHP_LAI$VZA <- NULL
DHP_LAI$method <- NULL
DHP_LAI_Hinge$endVZA <- 'Hinge'
DHP_LAI <- rbind(DHP_LAI, DHP_LAI_Hinge)
```


```{r apply clumping indices correctly}
DHP_LAI <- DHP_LAI %>%
  mutate(LAI.LX = canopy.Le/canopy.LX) %>%
  mutate(LAI.LXG1 = canopy.Le/canopy.LXG1) %>%
  mutate(LAI.LXG2 = canopy.Le/canopy.LXG2)
```

Date formatting, column renaming and LAI calculation for the Littertraps
```{r date formatting and column renaming}
# Ensure the date column is in Date format
DHP_LAI$date <- as.Date(DHP_LAI$date)

#DHP_LAI_2BG$date <- as.Date(DHP_LAI_2BG$date)
# Assuming LT_LAI$Date is numeric
LT_LAI$Date <- as.character(LT_LAI$Date)  # Convert to character

#merge values if there are 2 photos for one plot
# Summing up 'value' for rows with the same 'plot' and 'date'
LT_LAI <- LT_LAI %>%
  group_by(Plot, Date) %>%
  summarize(Leaf.Area..cm.. = sum(Leaf.Area..cm..), .groups = "drop")

LT_LAI$LAI <- LT_LAI$Leaf.Area..cm../2400
LT_LAI <- LT_LAI %>%
  rename(leaf_area_cm = Leaf.Area..cm..)
# Convert to date using the specified format
LT_LAI$Date <- as.Date(LT_LAI$Date, format = "%y%m%d")
LT_LAI <- as_tibble(LT_LAI)

names(LT_LAI) <- tolower(names(LT_LAI))    
```

Matching the LT data with the hemispheR data. This is done because the LT data always shows the difference in LAI for one timestep and not the absolute LAI. This is done for both ways: calculating the absolute value from the LT data and calculating the differences for each timestep for the hemispheR data.

```{r merging the two datasets}
# Merge the two datasets
merged_data_all <- merge(DHP_LAI, LT_LAI , by = c("plot", "date"), all = T)
```

### calculating the absolute LAI
Furthermore also changing the endVZA to factor because of the 'Hinge' angle is a character.
```{r calculating absolute LAI}
merged_data_cumulative <- merged_data_all %>%
  group_by(plot, endVZA) %>%
  mutate(
    # Shift the 'lai' values one timestep backward (i.e., add the lai from the next timestep)
    shifted_lai = lead(lai, order_by = date),  
    
    # Replace NA with 0 (the first timestep should start with the first lai value)
    shifted_lai = replace_na(shifted_lai, 0),
    
    # Compute cumulative sum of shifted 'lai' values (starting from 0 for the last timestep)
    absolute_lai = rev(cumsum(rev(shifted_lai)))
  ) %>%
  ungroup()

merged_data_cumulative$endVZA <- as.factor(merged_data_cumulative$endVZA)
```

```{r get rid of unnecessary columns}
merged_data_cumulative$canopy.DIFN <- NULL
merged_data_cumulative$leaf_area_cm <- NULL
merged_data_cumulative$lai <- NULL
merged_data_cumulative$shifted_lai <- NULL
```
```{r add leaf fall states}
# Define the time spans for each phase
begin_start <- as.Date("2024-09-20")  # Replace with the actual start date of "begin"
begin_end <- as.Date("2024-10-15")    # Replace with the actual end date of "begin"

peak_start <- as.Date("2024-10-16")   # Replace with the actual start date of "peak"
peak_end <- as.Date("2024-11-12")     # Replace with the actual end date of "peak"

end_start <- as.Date("2024-11-13")    # Replace with the actual start date of "end"
end_end <- as.Date("2024-12-16")      # Replace with the actual end date of "end"

# Add the `phase` column based on the defined timespans
merged_data_cumulative <- merged_data_cumulative %>%
  mutate(
    phase = case_when(
      date >= begin_start & date <= begin_end ~ "onset",  # Begin phase
      date >= peak_start & date <= peak_end ~ "peak",    # Peak phase
      date >= end_start & date <= end_end ~ "end",       # End phase
      TRUE ~ "other"                                     # If outside defined timespans
    )
  )

merged_data_cumulative_woconifer_phase <- merged_data_cumulative %>%
  filter(plot %in% plot_ids) %>%
  filter(phase == c("onset", "peak"))
```


## RESULTS
 
### Plots

```{r LAI OVER TIME}
# Filter data for LAI.LXG1 at 20° only and only sample points wo conifer trees
filtered_data <- merged_data_cumulative %>%
  filter(endVZA == 20) %>%
  filter(plot %in% plot_ids_wo_conifer)

# Calculate summary statistics for both actual LAI and LAI.LXG1 (20°)
summary_data <- filtered_data %>%
  group_by(date) %>%
  summarise(
    mean_actual_LAI = mean(absolute_lai, na.rm = TRUE),
    p5_actual_LAI = quantile(absolute_lai, 0.05, na.rm = TRUE),
    p95_actual_LAI = quantile(absolute_lai, 0.95, na.rm = TRUE),
    mean_LAI_LXG1 = mean(LAI.LXG1, na.rm = TRUE),
    p5_LAI_LXG1 = quantile(LAI.LXG1, 0.05, na.rm = TRUE),
    p95_LAI_LXG1 = quantile(LAI.LXG1, 0.95, na.rm = TRUE)
  )

# Create the plot
p <- ggplot(summary_data, aes(x = date)) +
  # Shaded region for actual LAI 5th-95th percentile range
  geom_ribbon(aes(ymin = p5_actual_LAI, ymax = p95_actual_LAI), fill = "black", alpha = 0.2) +
  # Shaded region for LAI.LXG1 (20°) 5th-95th percentile range
  geom_ribbon(aes(ymin = p5_LAI_LXG1, ymax = p95_LAI_LXG1), fill = "#1F77B4", alpha = 0.2) +
  # Line for mean actual LAI
  geom_line(aes(y = mean_actual_LAI, color = "Mean Actual LAI"), size = 1.2, linetype = "solid") +
  # Line for mean LAI.LXG1 (20°)
  geom_line(aes(y = mean_LAI_LXG1, color = "Mean LAI.LXG1"), size = 1, linetype = "solid") +  # Adjusted label
  labs(
    # title = "LAI Over Time: Actual vs. Estimated (LXG1, 20°)",
    x = "Date", 
    y = "LAI",
    color = NULL  # Remove legend title
  ) +
  scale_color_manual(values = c("Mean Actual LAI" = "black", "Mean LAI.LXG1" = "#1F77B4")) +  # Adjusted color entry
  theme_minimal() +
  theme(text = element_text(family = "Helvetica", size = 25),  # Set font to Helvetica
    plot.title = element_text(size = 25, face = "bold"),  # Increase title size
    axis.title.x = element_text(size = 25),  # Increase x-axis label size
    axis.title.y = element_text(size = 25),  # Increase y-axis label size
    axis.text.x = element_text(size = 25),   # Increase x-axis tick label size
    axis.text.y = element_text(size = 25),   # Increase y-axis tick label size
    legend.text = element_text(size = 25),    # Increase legend text size
    legend.title = element_blank(),            # Remove legend title
    legend.position = "bottom"
  )

# Save the plot
ggsave("results/LAI_over_time.png", plot = p, width = 10, height = 6, dpi = 300)



```

```{r LT LAI vs DHP LAI - LXG1 20° VZA}

plot_data <- merged_data_cumulative %>%
  filter(endVZA == 20) %>%
  filter(plot %in% plot_ids_wo_conifer)

# Define custom phase colors
custom_colors <- c("onset" = "#1F77B4",  # Blue
                   "peak" = "#2CA02C",  # Green
                   "end" = "#FF7F0E")  # Orange

# Function to create the plot
create_plot <- function(plot_data, x_var, y_var, method_name) {
  # Define a mapping of method names to display names
  method_labels <- c("canopy.Le" = "Effective LAI", 
                     "LAI.LXG1" = "Clumping LXG1 LAI")
  
  # Get the correct display name
  display_name <- method_labels[method_name]
  
  # Ensure phase order in the legend
  plot_data$phase <- factor(plot_data$phase, levels = c("onset", "peak", "end"))
  
  # Compute ranges
  x_range <- range(plot_data$absolute_lai, na.rm = TRUE)
  y_range <- range(plot_data[[y_var]], na.rm = TRUE)
  max_range <- max(c(x_range, y_range))
  
  # Fit the linear model
  lm_model <- lm(as.formula(paste(y_var, "~ absolute_lai")), data = plot_data)
  intercept <- coef(lm_model)["(Intercept)"]
  slope <- coef(lm_model)["absolute_lai"]
  r2 <- summary(lm_model)$r.squared
  
  # Format equation label
  eq_label <- sprintf("y = %.2f + %.2fx,\nR² = %.2f", intercept, slope, r2)
  
  # Create the plot
  p <- ggplot(data = plot_data, aes(x = absolute_lai, y = .data[[y_var]], color = phase)) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", color = "darkgrey", se = TRUE) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +
    geom_text(
      x = max_range * 0.05, 
      y = max_range * 0.95, 
      label = eq_label, 
      color = "black", 
      size = 5, 
      hjust = 0
    ) +
    coord_fixed(ratio = 1) +  
    xlim(0, max_range) + ylim(0, max_range) +  
    labs(
      x = "LT LAI",
      y = "DHP LAI",
      color = NULL
    ) +
    scale_color_manual(values = custom_colors) +  # Apply custom colors
    theme_minimal() +  
    theme(text = element_text(family = "Helvetica", size = 20),  # Set font to Helvetica
      legend.title = element_text(size = 20),
      legend.text = element_text(size = 20),
      axis.title = element_text(size = 20),
      axis.text = element_text(size = 20),
      plot.margin = margin(15, 15, 15, 15),
      legend.position = "bottom"  # Move legend below the plot
    )
  
  return(p)
}

# Create individual plots
plot2 <- create_plot(plot_data, "absolute_lai", "canopy.Le", "canopy.Le")
plot3 <- create_plot(plot_data, "absolute_lai", "LAI.LXG1", "LAI.LXG1")

# Combine the plots and center the legend
final_plot <- (plot2 + plot3) +  
  plot_layout(guides = "collect") &  # Collect the legend into one shared space
  theme(
    legend.position = "bottom"  # Center legend below both plots
  )

#either a combined plot or just use plot 3 for LXG1 only.
ggsave("results/LTvsDHP.png", 
       plot3, width = 10, height = 5, dpi = 300)

```


```{r Slope, Error and R2 plot}
# Define the methods and angles
methods_to_plot <- c("canopy.L", "canopy.Le", "LAI.LXG1", "LAI.LXG2")
vza_angles <- c(10, 20, 30, 40, 50, 60, 70, 80, 90)

# Initialize an empty dataframe to store results
slope_error_data <- data.frame()

# Loop through each VZA angle
for (vza in vza_angles) {
  # Filter data for the current VZA and plot IDs
  data_vza <- merged_data_cumulative %>%
    filter(endVZA == vza, plot %in% plot_ids)
  
  # Loop through each method
  for (method in methods_to_plot) {
    # Fit linear model: HemispheR LAI ~ Absolute LAI
    lm_model <- lm(data_vza[[method]] ~ data_vza$absolute_lai)
    
    # Extract slope
    slope_value <- coef(lm_model)[2]  # Second coefficient (absolute LAI)
    
    # Compute mean absolute error (MAE)
    abs_error_value <- mean(abs(data_vza[[method]] - data_vza$absolute_lai), na.rm = TRUE)
    
    # Compute R²
    r2_value <- summary(lm_model)$r.squared
    
    # Store the results
    slope_error_data <- rbind(slope_error_data, data.frame(
      endVZA = vza,
      method = method,
      abs_error = abs_error_value,
      slope = slope_value,
      r_squared = r2_value
    ))
  }
}

# Reshape data for plotting
slope_error_data_long <- slope_error_data %>%
  pivot_longer(cols = c(abs_error, slope, r_squared), 
               names_to = "metric", values_to = "value") %>%
  mutate(metric = factor(metric, 
                         levels = c("abs_error", "slope", "r_squared"),
                         labels = c("Absolute Error", "Slope", "R²")))

# Create the combined plot with facets
p <- ggplot(slope_error_data_long, aes(x = factor(endVZA, levels = vza_angles), y = value, color = method, group = method)) +
  geom_point(size = 3) +  # Slightly larger points
  geom_line(size = 1.2) +  # Slightly thicker lines
  facet_wrap(~metric, scales = "free_y", nrow = 1, strip.position = "left") +  # Move facet labels to Y-axis
  labs(x = "View Zenith Angle (VZA)", y = NULL, color = "Method") +  # X-axis label
  scale_color_manual(name = NULL, 
                     values = c("canopy.L" = "#1F77B4",   
                                "canopy.Le" = "#2CA02C",  
                                "LAI.LXG1" = "#D62728",  
                                "LAI.LXG2" = "#FF7F0E"),  
                     labels = c("canopy.Le" = "Effective LAI",
                                "canopy.L" = "Clumping LX", 
                                "LAI.LXG1" = "Clumping LXG1",  
                                "LAI.LXG2" = "Clumping LXG2")) +
  theme_minimal() +
  theme(text = element_text(family = "Helvetica"),  # Set font to Helvetica
        aspect.ratio = 1,  # Make plots more square
        strip.placement = "outside",  # Move facet labels to the left Y-axis
        strip.text.y = element_text(size = 16, face = "bold", angle = 90),  # Rotate facet labels, make them bold
        axis.text = element_text(size = 14),  # Increase tick label size
        axis.title.x = element_text(size = 16, vjust = -0.5),  # Increase X-axis label size and adjust position
        axis.title.y = element_text(size = 16),  # Ensure Y-axis label is included
        axis.text.x = element_text(angle = 30, hjust = 1),  # Angle x-axis labels for all plots
        legend.text = element_text(size = 14),  # Increase legend text size
        legend.title = element_text(size = 14, face = "bold"),  # Make legend title bold
        legend.position = "bottom",  # Move legend below the plot
        legend.direction = "horizontal")  # Place legend entries side-by-side

# Save as a larger image to ensure all text fits  
ggsave("results/absError_slope_R2.png", 
       p, width = 10, height = 5, dpi = 300)
```

```{r showcase VZA area}
# Parameters for the fisheye image
xc <- 1478      # x-coordinate of the center
yc <- 1478      # y-coordinate of the center
radius <- 1476  # Radius of the fisheye circle

# Zenith angles to visualize
zenith_angles <- c(10, 20, 30, 40, 50, 60, 70, 80, 90)

# Calculate the radii corresponding to zenith angles
zenith_radii <- sapply(zenith_angles, function(angle) {
  radius * sin(angle * pi / 180)
})

# Load and rotate the first image
fisheye_image1 <- image_read('/Volumes/Back 3/Ecosense_Art/LT23_20240920.jpg')
image_grob1 <- grid::rasterGrob(fisheye_image1, width = unit(1, "npc"), height = unit(1, "npc"))

# Load and rotate the second image by 180 degrees
fisheye_image2 <- image_read('/Volumes/Back 3/Ecosense_Art/LT23_20241216.jpg') %>%
  image_rotate(180)  # Rotate the image by 180 degrees
image_grob2 <- grid::rasterGrob(fisheye_image2, width = unit(1, "npc"), height = unit(1, "npc"))

# Check if images are loaded correctly
if (is.null(fisheye_image1) || is.null(fisheye_image2)) {
    stop("Error: One or both images did not load correctly.")
}

# Create a data frame for the rings
rings_data <- data.frame(
  x = xc,
  y = yc,
  radius = zenith_radii,
  angle = zenith_angles
)

# Define colors for angles
angle_colors <- c("purple", "blue", "cyan", "green", "orange", "yellow", "red", "magenta", "brown")

# Create the first plot (without legend)
plot1 <- ggplot() +
  annotation_custom(image_grob1, xmin = 0, xmax = 2 * xc, ymin = 0, ymax = 2 * yc) +
  geom_circle(data = rings_data, aes(x0 = x, y0 = y, r = radius, color = factor(angle)), size = 1) +
  scale_color_manual(values = angle_colors, guide = "none") +  # Hides legend
  coord_fixed() +
  theme_void() +
  theme(legend.position = "none")  # Ensure no legend

# Create the second plot (with the rotated image)
plot2 <- ggplot() +
  annotation_custom(image_grob2, xmin = 0, xmax = 2 * xc, ymin = 0, ymax = 2 * yc) +  # Use the rotated image
  geom_circle(data = rings_data, aes(x0 = x, y0 = y, r = radius, color = factor(angle)), size = 1) +
  scale_color_manual(values = angle_colors, guide = "none") +  # Hides legend
  coord_fixed() +
  theme_void() +
  theme(legend.position = "none")  # Ensure no legend

# Combine both plots side by side (legend removed)
final_plot <- plot1 + plot2 + plot_layout(guides = "collect")

# Display the final plot
print(final_plot)
ggsave("results/leafonoff_Zenithangle.png", plot = final_plot, width = 7, height = 3, dpi = 300) 

```

```{r MME MODEL}
# Initialize an empty dataframe for storing metrics
error_metrics_wo_conifer <- data.frame(
  endVZA = numeric(),
  metric = character(),
  value = numeric()
)

# Loop through each zenith angle for LAI.LXG1 only (excluding conifers)
for (angle in c(10, 20, 30, 40, 50, 60, 70, 80, 90)) {
  
  # Filter data for current VZA and exclude conifers
  data_filtered <- merged_data_cumulative %>%
    filter(endVZA == angle, plot %in% plot_ids_wo_conifer)
  
  # Fit mixed-effects model
  model_filtered <- lmer(absolute_lai ~ LAI.LXG1 + (1 | plot), data = data_filtered)
  
  # Compute residuals
  predictions <- predict(model_filtered, re.form = NULL)
  residuals <- data_filtered$absolute_lai - predictions
  
  # Extract fixed effect slope
  slope <- fixef(model_filtered)["LAI.LXG1"]
  
  # Compute **Marginal R²** (fixed effects only)
  r2_marginal <- r.squaredGLMM(model_filtered)[1]  # First value is marginal R²
  
  # Calculate MAE
  mae <- mean(abs(residuals))
  
  # Append results
  error_metrics_wo_conifer <- rbind(error_metrics_wo_conifer,
                                    data.frame(endVZA = angle, metric = "R² Marginal", value = r2_marginal),
                                    data.frame(endVZA = angle, metric = "MAE", value = mae),
                                    data.frame(endVZA = angle, metric = "Fixed Effect Slope", value = slope))
}

# Convert endVZA to factor for consistent plotting
error_metrics_wo_conifer$endVZA <- factor(error_metrics_wo_conifer$endVZA, levels = unique(error_metrics_wo_conifer$endVZA))

# Function to create separate plots for each metric **without titles or captions**
plot_error_metric <- function(data, metric_name) {
  ggplot(data %>% filter(metric == metric_name),
         aes(x = endVZA, y = value, group = 1)) +
    geom_point(size = 3, color = "#1F77B4") +  
    geom_line(size = 1, color = "#1F77B4") +   
    labs(x = "Zenith Angle", y = metric_name) +  # Only axis labels
    theme_minimal() +
    theme(
      text = element_text(family = "Helvetica", size = 20),
      plot.title = element_blank(),  # Remove title
      axis.text.x = element_text(angle = 30, hjust = 1),
      plot.margin = margin(5, 5, 5, 5),  # Reduce extra spacing
      strip.text.y = element_text(size = 16, face = "bold", angle = 90)  # Rotate facet labels, make them bold
    )
}

# Generate individual plots
r2_plot <- plot_error_metric(error_metrics_wo_conifer, "R² Marginal")  
mae_plot <- plot_error_metric(error_metrics_wo_conifer, "MAE")
slope_plot <- plot_error_metric(error_metrics_wo_conifer, "Fixed Effect Slope")

# Ensure a 3-Column Layout
final_plot <- (r2_plot + mae_plot + slope_plot) + plot_layout(ncol = 3)

# Save and display with individual plots being quadratic
ggsave("results/Marginal_R2_MAE_Slope_LAI_LXG1_wo_conifer.png", 
       plot = final_plot, width = 12, height = 4, dpi = 300)  # Wider aspect ratio for the full figure

```

